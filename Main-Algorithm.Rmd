---
title: "Predictive Wavelength Switching Project"
# This code provides the best wavelength choices for 3-add events with 8 pre-existing channels
 
output: bookdown::gitbook
site: bookdown::bookdown_site
---
```{r setup, include=FALSE, message=FALSE}
knitr::opts_chunk$set(echo = TRUE, message=FALSE, eval = T)
library(caret); library(stringr); library(dplyr); library(readxl)

library(gtools); library(stringr)
library(dplyr)
```

# Index

Predict the value of the gain at other channels by having few input channels

# Data Preparation

## Path and names should be specified here.

```{r}
# Give the values
# * directory with data
data_dir_path <- "./data/"
# * name of the file with fully loaded bands
FLB_filename <- "Fully Loaded Band.xlsx"
# * names of coloumns in files
col_names <- c("Freq", "wl", "PowerIn", "PowerOut", "Gain")

# number of add-events
num_add_ev <- 3

# m paramete defines the gap for diveregence of power between ripples, the ideal value for m is 0.
m=0.08

```

## Reading data

```{r data}

#################################################
# Detecting files with data
all_files_in_data_dir <- dir(data_dir_path)
# Choose only excel files
data_files <- str_subset(all_files_in_data_dir, ".xlsx")
# List files included
data_files 

if(exists("tbl_Total")) rm(tbl_Total)

# read fully loaded bands file
tb_FLB <- read_excel(str_c(data_dir_path, FLB_filename), skip = 1)
names(tb_FLB) <- col_names

#how many distinct frequencies in fully loaded bands file
num_FLB <- length(unique(tb_FLB$Freq))

```

## create IDs for frequencies

```{r}
freq_map <- select(tb_FLB, Freq) %>%
  arrange(Freq) %>%
  mutate(freq_text_id = str_c("g_", str_pad(1:num_FLB, 2, pad = "0")),
         freq_num_id = str_pad(1:num_FLB, 2, pad = "0")) # as.numeric

# checking
freq_map
```

## Calculation of ratios for all data files

* Read all files in data folder and combine them to one tibble
* Perform calculation of ratios

```{r}
for(cur_file in data_files){
  temp_df <- read_excel(str_c(data_dir_path, cur_file), skip = 1)
  names(temp_df) <- c("Freq", "wl", "PowerIn", "PowerOut", "Gain")
  
  # add frequency IDs to corresponding places 
  temp_df <- temp_df %>%
    full_join(freq_map)
  
  # add coloumn containing name of the file
  temp_df$name <- cur_file
  
  # calculate ratios
  for(id in temp_df$freq_text_id){
    root_gain <- filter(temp_df, freq_text_id == id) %>% 
      select(Gain) %>% unlist()
    temp_df[, str_c(id, "_over")] <- 
      (10^(temp_df$Gain/10)) / (10^(root_gain/10))
  }

  # put data to one total tibble
  if(!exists("tbl_Total")) {
    temp_df <- temp_df[, sort(names(temp_df))]
    tbl_Total <- temp_df
  }else{
      tbl_Total <- rbind(tbl_Total, temp_df)
      }
}
  
# check validity of results
tbl_Total %>% filter(g_01_over == 1) %>% select(Freq, name)
tbl_Total %>% filter(g_15_over == 1) %>% select(Freq, name)

# create number of channels column (files stored data with various N of chan-s)
tbl_Total <- tbl_Total %>% 
  group_by(name) %>% 
  mutate(num_of_channels = sum(! is.na(Gain))) %>%
  ungroup()

# cheking
tbl_Total %>% group_by(name) %>% summarise(unique(num_of_channels))
```

# Plots

```{r}
library(ggplot2)

# Plot Output power spectrum over channel 45th power with a small power gap between fully loaded band and input channel loading

ggplot(tbl_Total, aes(y= g_45_over, x = Freq)) + 
  geom_point(aes(color = name, shape = factor(num_of_channels)), size = 2) +
  labs(shape ='Number of Channels') +
  labs(color ='Data file name') +
  ylab("Channel Power / Channel 45-th Power")

# make plot interactive
#library(plotly)
#ggplotly()

# try another
ggplot(tbl_Total, aes(y= g_21_over, x = Freq)) + 
  geom_point(aes(color = name, shape = factor(num_of_channels)), size = 2)
```

# Function

## Determine Pre-existing channels in Input

```{r}
pre_exsit_channels <- tbl_Total %>%
  filter(name == "Input.xlsx") %>%
  select(Gain, freq_num_id) %>%
  filter(!is.na(Gain)) %>%
  select(freq_num_id) %>%
  unlist() 

pre_exsit_channels

pr_exsit_ch_names <- str_c("g_", pre_exsit_channels, "_over")
```

* Do we need this function?

```{r}
compare_test <- function(tbl_Total, file_name, margin) {
  
  # By stacking all pre-existing channel in xx file, We make sure the newly proposed channels are not repetitive.
  v = 1
  
  myf = function(x){abs(x - v) < margin} # function to apply to filtering condition

  df_temp <- filter(tbl_Total, name == file_name) %>%
    select(Freq, freq_num_id, freq_text_id,
           match(pr_exsit_ch_names, names(.))) %>% # selecting col with pre_exist_ch.
    mutate_each(funs(TF = myf),                    # applying margin condition
                -Freq, -freq_num_id, -freq_text_id) %>%
    # take only those rows, where all conditions are TRUE:
    filter(rowSums(.[, str_detect(names(.), "TF")]) == 
             sum(str_detect(names(.), "TF"))) %>% 
    select(-ends_with("TF"))
  
  df_temp
}
 
####################
 
#check funtion in action
df2NotNA <- c("g_15", "g_21", "g_27", "g_33", "g_39", "g_45", "g_51", "g_46")
#0.01551
xx <- compare_test(tbl_Total, data_files[1], margin = 1) %>%
  #sum_ans <<- sum(xx$g_33_over, na.rm = T)
  filter(! freq_text_id %in% df2NotNA ) 
  
   
```

# Setup parameters

* Can we setup them automatically?


```{r}
# b parameter defines the number of newly added wavelengths
b=num_add_ev

# a parameter defines the number of wavelengths after add events
a=num_add_ev + length(pre_exsit_channels)
p=a

## zz1 defines the total number of possible combination to pick 3 wavelenths out of 80 (excluing pre-existing wavelengths)
zz1 <-combn(xx$g_15_over, b, simplify=F)

# zzz2 parameter gives the freq_text_id of the 3 newly proposed channels. Type: zzz2[( k parameter value)]

###################################################
###########Algorithm OUTCOMEs
zzz2 <-combn(xx$freq_text_id, b, simplify=F)

# zzz4 parameter gives the num-id of the 3 newly proposed channels. Type: zzz4[( k parameter value)]
zzz4 <-combn(xx$freq_num_id, b, simplify=F)
  # zzz3 parameter gives the frequencies of the 3 newly proposed channels. This paprameter is the main OUTCOME of this algorithm. Type: zzz3[( k parameter value)]

zzz3 <-combn(xx$Freq, b, simplify=F)
####################################################
m3=m

```



```{r}

############## Algorithm Core 
c<-1
k<-1
  

while(c <= length(zz1)){
  dff3 <- tbl_Total %>%
    filter(
      name == "Fully Loaded Band.xlsx",
      freq_num_id %in% as.numeric( c(pre_exsit_channels, zzz4[[k]] ) )) 
    
  #checking_these_names <- c(pr_exsit_ch_names, str_c(zzz2[[k]], "_over"))
  
  condition_check_1 <- dff3 %>%
    select(match( pr_exsit_ch_names, names(.))) %>%
    summarize_each(funs( abs( sum(., na.rm = T)-a) > m3 ) ) %>%
    unlist() %>%
    sum()

  condition_check_2 <- dff3 %>%
    select(match( str_c(zzz2[[k]], "_over"), names(.))) %>%
    filter(row_number() <= p) %>%
    summarize_each(funs( abs( sum(., na.rm = T)-a) > m ) ) %>%
    unlist() %>%
    sum()
  
  # "OR" condition - at least 1 is True
  if (condition_check_1 + condition_check_2 >= 1){k <- k + 1}
  
  c <- c + 1
}

print(c)
print(k)
```

# The proposed wawelength 

Based on calculations proposend frequencies are

```{r}
zzz3[k]
```

